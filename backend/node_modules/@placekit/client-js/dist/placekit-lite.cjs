/*! @placekit/client-js v2.3.0 | Â© placekit.io | MIT license | https://github.com/placekit/client-js#readme */
'use strict';

const extensions = new Map();
function getUserAgent() {
  const chunks = [];
  if (typeof window !== 'undefined' && navigator.userAgent) {
    chunks.push(navigator.userAgent);
  }
  chunks.push(`PlaceKit/2.3.0 (Client=JavaScript)`);
  if (typeof process !== 'undefined' && process.version) {
    chunks.push(`NodeJS/${process.version}`);
  }
  return chunks.join(' ');
}
function placekit(apiKey, options = {}) {
  if (!['string', 'undefined'].includes(typeof apiKey)) {
    throw Error('PlaceKit: `apiKey` argument is invalid, expected a string.');
  } else if (!apiKey) {
    console.warn('PlaceKit: missing or empty `apiKey` argument.');
  }
  let currentHost = 0;
  const hosts = [`https://api.placekit.co`];
  let hasGeolocation = false;
  const globalParams = {
    maxResults: 5,
  };
  if (typeof window !== 'undefined' && navigator.language) {
    globalParams.language = navigator.language.slice(0, 2);
  }
  const userAgent = getUserAgent();
  function request(method = 'POST', resource = '', opts = {}) {
    const { timeout, forwardIP, ...params } = opts;
    const controller = new AbortController();
    const id =
      typeof timeout !== 'undefined' ? setTimeout(() => controller.abort(), timeout) : undefined;
    const url = new URL(resource.trim().replace(/^\/+/, ''), hosts[currentHost]);
    if (['GET', 'HEAD'].includes(method) && typeof params !== 'undefined') {
      Object.keys(params).forEach((k) => url.searchParams.append(k, params[k]));
    }
    const headers = {
      'Content-Type': 'application/json; charset=UTF-8',
      'User-Agent': userAgent,
      'x-placekit-api-key': apiKey,
    };
    if (forwardIP) {
      headers['x-forwarded-for'] = forwardIP;
    }
    return fetch(url, {
      method,
      headers,
      signal: controller.signal,
      body: !['GET', 'HEAD'].includes(method) ? JSON.stringify(params) : undefined,
    })
      .then(async (res) => {
        clearTimeout(id);
        const body = await res.json();
        if (!res.ok) {
          throw {
            status: res.status,
            statusText: res.statusText,
            ...body,
          };
        }
        return body;
      })
      .catch((err) => {
        if (err.name === 'AbortError' || (err.status && err.status >= 500)) {
          currentHost++;
          if (currentHost < hosts.length - 1) {
            return request(method, resource, opts);
          }
        }
        throw err;
      });
  }
  const client = {
    get options() {
      return globalParams;
    },
    get hasGeolocation() {
      return hasGeolocation;
    },
    configure(opts = {}) {
      if (!['object', 'undefined'].includes(typeof opts) || Array.isArray(opts) || opts === null) {
        throw Error('PlaceKit.configure: `opts` argument is invalid, expected an object.');
      }
      Object.assign(globalParams, opts);
    },
    requestGeolocation(opts = {}) {
      if (!['object', 'undefined'].includes(typeof opts) || Array.isArray(opts) || opts === null) {
        throw Error('PlaceKit.requestGeolocation: `opts` argument is invalid, expected an object.');
      }
      return new Promise((resolve, reject) => {
        if (typeof window === 'undefined' || !navigator.geolocation) {
          reject(
            Error('PlaceKit.requestGeolocation: geolocation is only available in the browser.'),
          );
        } else {
          navigator.geolocation.getCurrentPosition(
            (pos) => {
              hasGeolocation = true;
              globalParams.coordinates = `${pos.coords.latitude},${pos.coords.longitude}`;
              resolve(pos);
            },
            (err) => {
              hasGeolocation = false;
              delete globalParams.coordinates;
              reject(Error(`PlaceKit.requestGeolocation: (${err.code}) ${err.message}`));
            },
            opts,
          );
        }
      });
    },
    clearGeolocation() {
      hasGeolocation = false;
      delete globalParams.coordinates;
    },
  };
  for (const [resource, init] of extensions.entries()) {
    if (resource in client) {
      throw Error(`PlaceKit extend: \`client.${resource}\` already exists.`);
    }
    client[resource] = init(request, client);
  }
  client.configure(options);
  return client;
}
placekit.extend = function (resource, init) {
  if (!init?.call) {
    throw Error('PlaceKit extend: `init` argument is invalid, expected a function.');
  }
  extensions.set(resource, init);
};
placekit.extend('search', (request, client) => (query, opts = {}) => {
  if (!['string', 'undefined'].includes(typeof query)) {
    throw Error('PlaceKit `client.search`: `query` argument is invalid, expected a string.');
  }
  if (!['object', 'undefined'].includes(typeof opts) || Array.isArray(opts) || opts === null) {
    throw Error('PlaceKit.search: `opts` argument is invalid, expected an object.');
  }
  return request('POST', 'search', {
    ...client.options,
    ...opts,
    query,
  });
});
placekit.extend('reverse', (request, client) => (opts = {}) => {
  if (!['object', 'undefined'].includes(typeof opts) || Array.isArray(opts) || opts === null) {
    throw Error('PlaceKit.reverse: `opts` argument is invalid, expected an object.');
  }
  return request('POST', 'reverse', {
    ...client.options,
    ...opts,
  });
});

module.exports = placekit;
